<!-- FILE: src/components/FullTranscriptPage.vue - FULL FUNCTIONALITY -->
<template>
  <div class="notebook-page full-transcript-page">
    <div class="page-header">
      <h3 class="page-title">Full Transcript</h3>
      <div class="header-actions"> 
        <button 
          v-if="selectedTextInternal" 
          @click="requestSelectedTextExplanation" 
          class="explain-selection-action-button">
          Explain Selection
        </button>
        <div class="mode-selector-wrapper">
          <label for="transcript-mode-select" class="mode-label">View Mode:</label>
          <select id="transcript-mode-select" v-model="currentTranscriptMode" class="mode-dropdown">
            <option value="interactive_click_sync">Interactive - Click to Sync</option>
            <option value="interactive_full_sync">Interactive - Follow Playback</option>
            <option value="static_timestamped">Static - Timestamps</option>
            <option value="static_article">Static - Article View</option>
          </select>
        </div>
      </div>
    </div>
    
    <div class="transcript-content-wrapper">
      <div 
        class="transcript-scroll-area" 
        ref="fullTranscriptScrollAreaRef" 
        @scroll="handleManualScrollDebounced"
        @mousedown="handleScrollAreaMouseDown"
        @mouseup="handleScrollAreaMouseUp"> <!-- General mouseup on scroll area to catch selections -->
        
        <div v-if="currentTranscriptMode === 'static_article'" class="article-view-content">
          <div v-if="formattedArticleText"><pre class="article-text-formatted">{{ formattedArticleText }}</pre></div>
          <div v-else-if="props.rawTranscriptText" class="raw-transcript-as-article">
            <p v-for="(paragraph, pIndex) in rawTranscriptParagraphs" :key="'p-'+pIndex" class="article-paragraph">
              {{ paragraph }}
            </p>
          </div>
          <div v-else class="no-transcript-placeholder-full"><p><i>Article view will be generated by AI. Process a video first.</i></p></div>
        </div>

        <div v-else-if="props.transcriptSegments && props.transcriptSegments.length > 0" class="segmented-transcript-display">
          <p v-for="(segment, index) in props.transcriptSegments" 
             :key="segment.start + '-' + index + '-full'" 
             :data-start="segment.start"
             :data-duration="segment.duration"
             :id="'full-transcript-segment-' + index"
             @mousedown="onSegmentMouseDown($event)" 
             @mouseup="onSegmentMouseUp($event, parseFloat(segment.start))" 
             @mousemove="onSegmentMouseMove($event)"
             class="transcript-segment-full"
             :class="{ 
               'active-highlight': shouldHighlight(index),
               'clickable-segment': isSegmentClickable()
             }">
            <span class="segment-time" 
                  :class="{'clickable-timestamp': isSegmentClickable()}"
                  @click.stop="isSegmentClickable() && handleTimestampClick(parseFloat(segment.start))">
              [{{ formatTime(segment.start) }}]
            </span> 
            {{ segment.text }} 
          </p>
        </div>
        <pre v-else-if="props.rawTranscriptText && currentTranscriptMode !== 'static_article'" 
             class="raw-transcript-text-full">{{ props.rawTranscriptText }}</pre>
        <div v-else class="no-transcript-placeholder-full">
          <p><i>Transcript not available or video not processed.</i></p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { defineProps, defineEmits, ref, watch, nextTick, onMounted, onUnmounted, computed, onActivated, onDeactivated } from 'vue';

const props = defineProps({
  rawTranscriptText: { type: String, default: '' },
  transcriptSegments: { type: Array, default: () => [] },
  currentVideoTime: { type: Number, default: 0 }
});
const emit = defineEmits(['segment-clicked', 'explain-text-requested']);

const fullTranscriptScrollAreaRef = ref(null);
const currentlyActiveSegmentIndex = ref(-1);
const currentTranscriptMode = ref('interactive_click_sync'); 

// --- State for Click vs. Drag vs. Selection ---
const isDraggingInternally = ref(false); 
const mouseDownStartPos = ref({ x: 0, y: 0 });
const selectedTextInternal = ref('');    
const MIN_SELECTION_LENGTH_FOR_EXPLAIN = 3; // Min chars to show "Explain" button
let selectionTimeout = null;


const formattedArticleText = ref(null); // For future LLM formatted article
const rawTranscriptParagraphs = computed(() => { 
    return props.rawTranscriptText ? props.rawTranscriptText.split(/\n\s*\n|\n(?=\s*[A-Z-—–])|\n(?=\s*-\s)/).map(p => p.trim()).filter(p => p) : []; 
});

const formatTime = (totalSeconds) => { 
  if (typeof totalSeconds !== 'number' || isNaN(totalSeconds)) return '00:00';
  const minutes = Math.floor(totalSeconds / 60); 
  const seconds = Math.floor(totalSeconds % 60); 
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
};

const isSegmentClickable = () => currentTranscriptMode.value === 'interactive_click_sync' || currentTranscriptMode.value === 'interactive_full_sync';
const shouldHighlight = (index) => (currentTranscriptMode.value === 'interactive_full_sync') && (index === currentlyActiveSegmentIndex.value);

// --- Selection Handling ---
const updateSelectedTextState = () => {
  if (!fullTranscriptScrollAreaRef.value) return; 

  const selection = window.getSelection();
  const text = selection?.toString().trim() ?? '';

  if (text.length >= MIN_SELECTION_LENGTH_FOR_EXPLAIN) {
    let parentNode = selection?.anchorNode;
    let selectionIsValid = false;
    while (parentNode) {
      if (parentNode === fullTranscriptScrollAreaRef.value) {
        selectionIsValid = true;
        break;
      }
      parentNode = parentNode.parentNode;
    }
    selectedTextInternal.value = selectionIsValid ? text : '';
  } else {
    selectedTextInternal.value = ''; 
  }
  // console.log("FTSPage: Updated selectedTextInternal:", `"${selectedTextInternal.value}"`);
};

const handleScrollAreaMouseUp = () => { // Attached to .transcript-scroll-area
  // This will run after onSegmentMouseUp if the mouseup was on a segment.
  // The timeout helps ensure selection is finalized.
  clearTimeout(selectionTimeout);
  selectionTimeout = setTimeout(updateSelectedTextState, 60); // Slightly longer delay
};

const handleScrollAreaMouseDown = (event) => {
  if (!event.target.closest('.explain-selection-action-button')) {
    // If not clicking the explain button, clear selection to allow new selection
    // or to hide button if clicking on empty space.
    window.getSelection()?.empty() || window.getSelection()?.removeAllRanges(); 
    selectedTextInternal.value = ''; 
  }
};

const requestSelectedTextExplanation = () => {
  if (selectedTextInternal.value) {
    emit('explain-text-requested', selectedTextInternal.value);
    selectedTextInternal.value = ''; 
  }
};

// --- Segment Click/Drag Handling ---
const onSegmentMouseDown = (event) => { 
  isDraggingInternally.value = false; 
  mouseDownStartPos.value = { x: event.clientX, y: event.clientY };
  // Don't clear selectedTextInternal here immediately, 
  // handleScrollAreaMouseDown or subsequent selection will handle it.
};

const onSegmentMouseMove = (event) => { 
  if (!event.buttons) { // Mouse button not pressed (e.g., drag started then released outside)
    isDraggingInternally.value = false; // Ensure drag state is reset
    mouseDownStartPos.value = {x: 0, y:0};
    return;
  }
  if (mouseDownStartPos.value.x === 0 && mouseDownStartPos.value.y === 0) return; // Mousedown didn't start on a segment

  const deltaX = Math.abs(event.clientX - mouseDownStartPos.value.x); 
  const deltaY = Math.abs(event.clientY - mouseDownStartPos.value.y); 
  if (deltaX > 5 || deltaY > 5) { 
    isDraggingInternally.value = true; 
  }
};

const onSegmentMouseUp = (event, startTime) => { 
  const wasDragging = isDraggingInternally.value; 
  
  // Perform selection check slightly after mouseup to get final selection state
  setTimeout(() => {
    const currentSelectionText = window.getSelection()?.toString().trim() || '';
    if (isSegmentClickable() && !wasDragging && !currentSelectionText) { 
      emit('segment-clicked', startTime);
    }
    // Update selection state for the button in all cases after segment mouseup
    updateSelectedTextState(); 
  }, 10); // Short delay

  isDraggingInternally.value = false; 
  mouseDownStartPos.value = { x: 0, y: 0 };
};

const handleTimestampClick = (startTime) => { 
    if (!isSegmentClickable()) return; 
    emit('segment-clicked', startTime);
};

// --- Auto-scroll and Highlighting Logic ---
const userHasScrolledManually = ref(false); 
let scrollDebounceTimeout = null; 
let manualScrollHandlerDebounceTimer = null;

const handleManualScroll = () => { 
  if (currentTranscriptMode.value !== 'interactive_full_sync') return; 
  userHasScrolledManually.value = true; 
  clearTimeout(scrollDebounceTimeout); 
  scrollDebounceTimeout = setTimeout(() => { userHasScrolledManually.value = false; }, 2500); 
};
const handleManualScrollDebounced = () => { 
  clearTimeout(manualScrollHandlerDebounceTimer); 
  manualScrollHandlerDebounceTimer = setTimeout(handleManualScroll, 100);
};
const updateActiveSegmentAndScroll = (newTime) => { 
  if (currentTranscriptMode.value !== 'interactive_full_sync' || !props.transcriptSegments || props.transcriptSegments.length === 0) { 
    currentlyActiveSegmentIndex.value = -1; return; 
  } 
  let activeIdx = -1; 
  for (let i = 0; i < props.transcriptSegments.length; i++) { 
    const segment = props.transcriptSegments[i]; 
    const segmentStart = parseFloat(segment.start); 
    const segmentDuration = parseFloat(segment.duration); 
    let segmentEnd; 
    if (i + 1 < props.transcriptSegments.length) { 
      segmentEnd = parseFloat(props.transcriptSegments[i + 1].start); 
    } else { 
      segmentEnd = segmentStart + segmentDuration + 0.5; 
    } 
    if (newTime >= segmentStart && newTime < segmentEnd) { 
      activeIdx = i; break; 
    } 
  } 
  if (currentlyActiveSegmentIndex.value !== activeIdx) { 
    currentlyActiveSegmentIndex.value = activeIdx; 
  } 
  if (activeIdx !== -1 && !userHasScrolledManually.value) { 
    nextTick(() => { 
      const activeEl = document.getElementById(`full-transcript-segment-${activeIdx}`); 
      if (activeEl && fullTranscriptScrollAreaRef.value) { 
        activeEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' }); 
      } 
    }); 
  }
};

// --- Watchers ---
watch(() => props.currentVideoTime, (newTime) => { 
  if (currentTranscriptMode.value === 'interactive_full_sync') { 
    updateActiveSegmentAndScroll(newTime); 
  } else { 
    currentlyActiveSegmentIndex.value = -1; 
  }
});
watch(currentTranscriptMode, (newMode) => { 
  selectedTextInternal.value = ''; // Clear selection on any mode change
  if (newMode === 'interactive_full_sync') { updateActiveSegmentAndScroll(props.currentVideoTime); } 
  else { currentlyActiveSegmentIndex.value = -1; } 
  userHasScrolledManually.value = false; 
});

// --- Lifecycle Hooks ---
onMounted(() => { 
  // Global mouseup listener for selection detection, now part of the component's lifecycle
  // document.addEventListener('mouseup', handlePageMouseUp_Global_Debounced); // We are using @mouseup on scroll area
  if(currentTranscriptMode.value === 'interactive_full_sync') { 
    updateActiveSegmentAndScroll(props.currentVideoTime); 
  }
});
onUnmounted(() => { 
  // document.removeEventListener('mouseup', handlePageMouseUp_Global_Debounced);
  clearTimeout(scrollDebounceTimeout); 
  clearTimeout(manualScrollHandlerDebounceTimer);
  clearTimeout(selectionTimeout); 
});
onDeactivated(() => { 
  selectedTextInternal.value = ''; 
});
onActivated(() => { 
  // When tab is re-activated, check current selection state
  setTimeout(updateSelectedTextState, 50); 
  if(currentTranscriptMode.value === 'interactive_full_sync') { 
    updateActiveSegmentAndScroll(props.currentVideoTime); 
  }
});
</script>

<style scoped>
/* Styles are the same as your last working version with the static "Explain Selection" button in .header-actions */
.notebook-page.full-transcript-page { width: 100%; flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0; padding: 0; box-sizing: border-box;}
.page-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75em; border-bottom: 1px solid #eee; padding-bottom: 0.5em; flex-shrink: 0; }
.page-title { color: var(--color-heading); font-weight: 600; font-size: 1.5em; margin: 0; border-bottom: none; padding-bottom: 0;}
.header-actions { display: flex; align-items: center; gap: 10px; }
.explain-selection-action-button { padding: 5px 10px; font-size: 0.8em; background-color: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; white-space: nowrap; }
.explain-selection-action-button:hover { background-color: #138496; }
.mode-selector-wrapper { display: flex; align-items: center; gap: 8px; }
.mode-label { font-size: 0.9em; color: #555; }
.mode-dropdown { padding: 6px 10px; font-size: 0.9em; border: 1px solid #ccc; border-radius: 4px; background-color: #f8f8f8; color: #333; cursor: pointer; min-width: 220px; }
.mode-dropdown:hover { border-color: #aaa; } .mode-dropdown:focus { border-color: #007bff; box-shadow: 0 0 0 1px #007bff; outline: none;}
.transcript-content-wrapper { flex-grow: 1; display: flex; flex-direction: column; min-height: 0; overflow: hidden; position: relative; }
.transcript-scroll-area { position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow-y: auto; padding: 15px; background-color: #fff; font-size: 15px; line-height: 1.7; color: #333;}
.article-text-formatted { white-space: pre-wrap; word-wrap: break-word; font-family: 'Georgia', 'Times New Roman', serif; font-size: 16px; line-height: 1.8; color: #222;}
.raw-transcript-as-article h4 { font-size: 1.2em; font-weight: 600; margin-top: 1em; margin-bottom: 0.5em; color: var(--color-heading);}
.raw-transcript-as-article h4:first-of-type { margin-top: 0;}
.article-paragraph { margin-bottom: 1em; user-select:text; }
.segmented-transcript-display .transcript-segment-full { margin-bottom: 0.4em; padding: 4px 6px; border-radius: 3px; display: block; user-select: text; transition: background-color 0.1s ease-out;}
.segmented-transcript-display .transcript-segment-full.clickable-segment:hover { background-color: #e9ecef; }
.segmented-transcript-display .transcript-segment-full.active-highlight .segment-time { color: #c82333; font-weight: bold; }
.segment-time { display: inline-block; width: 55px; color: #0069d9; font-weight: 500; margin-right: 10px; font-size: 0.85em; transition: color 0.2s, font-weight 0.2s; user-select: none; }
.transcript-segment-full.clickable-segment .segment-time { cursor: pointer; }
.raw-transcript-text-full { white-space: pre-wrap; word-wrap: break-word; font-family: 'Menlo', 'Consolas', 'Courier New', monospace; font-size: 14px; line-height: 1.6; color: #2c3e50; margin: 0; user-select:text;}
.no-transcript-placeholder-full { display: flex; align-items: center; justify-content: center; height: 100%; text-align: center; color: #888; font-style: italic;}
</style>