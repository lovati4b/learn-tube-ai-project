<!-- FILE: src/components/FullTranscriptPage.vue - REORDERED MODES, NEW DEFAULT, STYLED DROPDOWN -->
<template>
  <div class="notebook-page full-transcript-page">
    <div class="page-header">
      <h3 class="page-title">Full Transcript</h3>
      <div class="mode-selector-wrapper">
        <label for="transcript-mode-select" class="mode-label">View Mode:</label>
        <select id="transcript-mode-select" v-model="currentTranscriptMode" class="mode-dropdown">
          <option value="static_article">Article View</option> <!-- Default -->
          <option value="static_timestamped">Static (Timestamps)</option>
          <option value="interactive_click_sync">Interactive (Click to Sync)</option>
          <option value="interactive_full_sync">Interactive (Follow Playback)</option>
        </select>
      </div>
    </div>
    
    <div class="transcript-content-wrapper">
      <div 
        class="transcript-scroll-area" 
        ref="fullTranscriptScrollAreaRef" 
        @scroll="handleManualScrollDebounced">
        
        <!-- Mode: Static Article View -->
        <div v-if="currentTranscriptMode === 'static_article'" class="article-view-content">
          <div v-if="formattedArticleText"> <!-- Placeholder for LLM formatted text -->
            <pre class="article-text-formatted">{{ formattedArticleText }}</pre> 
          </div>
          <div v-else-if="props.rawTranscriptText" class="raw-transcript-as-article">
            <!-- Simple paragraph split for placeholder if no LLM formatting yet -->
            <p v-for="(paragraph, pIndex) in rawTranscriptParagraphs" :key="'p-'+pIndex" class="article-paragraph">
              {{ paragraph }}
            </p>
          </div>
          <div v-else class="no-transcript-placeholder-full">
            <p><i>Article view will be generated by AI. Process a video first.</i></p>
          </div>
        </div>

        <!-- Modes: Static (Timestamps), Interactive (Click to Sync), Interactive (Follow Playback) -->
        <div v-else-if="props.transcriptSegments && props.transcriptSegments.length > 0" class="segmented-transcript-display">
          <p v-for="(segment, index) in props.transcriptSegments" 
             :key="segment.start + '-' + index + '-full'" 
             :data-start="segment.start"
             :data-duration="segment.duration"
             :id="'full-transcript-segment-' + index"
             @mousedown="onSegmentMouseDown"
             @mouseup="onSegmentMouseUp(parseFloat(segment.start))"
             @mousemove="onSegmentMouseMove"
             class="transcript-segment-full"
             :class="{ 
               'active-highlight': shouldHighlight(index), /* For 'interactive_full_sync' */
               'clickable-segment': isSegmentClickable()  /* For 'interactive_click_sync' & 'interactive_full_sync' */
             }">
            <span class="segment-time" 
                  :class="{'clickable-timestamp': isSegmentClickable()}"
                  @click.stop="isSegmentClickable() && handleTimestampClick(parseFloat(segment.start))">
              [{{ formatTime(segment.start) }}]
            </span> 
            {{ segment.text }} 
          </p>
        </div>
        <!-- Fallback for raw text if segments are not available for timestamped/interactive modes -->
        <pre v-else-if="props.rawTranscriptText && currentTranscriptMode !== 'static_article'" class="raw-transcript-text-full">{{ props.rawTranscriptText }}</pre>
        <div v-else class="no-transcript-placeholder-full">
          <p><i>Transcript not available or video not processed.</i></p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { defineProps, defineEmits, ref, watch, nextTick, onMounted, onUnmounted, computed } from 'vue';

const props = defineProps({
  rawTranscriptText: { type: String, default: '' },
  transcriptSegments: { type: Array, default: () => [] },
  currentVideoTime: { type: Number, default: 0 }
});

const emit = defineEmits(['segment-clicked']);

const fullTranscriptScrollAreaRef = ref(null);
const currentlyActiveSegmentIndex = ref(-1);
const currentTranscriptMode = ref('static_article'); // Default mode changed

const isDragging = ref(false);
const mouseDownPos = ref({ x: 0, y: 0 });

// Placeholder for LLM formatted text for "Static - Article View"
const formattedArticleText = ref(null); 

// Computed property to get raw text without timestamps for article view
const cleanRawTranscriptForArticle = computed(() => {
  if (!props.rawTranscriptText) return '';
  // Regex to find timestamps like [00:00], 00:00, 0:00:00, etc. at the start of lines or within text
  // and remove them. This regex is a bit more aggressive.
  // It looks for optional brackets, then HH:MM:SS.mmm or MM:SS.mmm or MM:SS
  // and the space that might follow.
  const timestampRegex = /\[?(?:(?:\d{1,2}:)?\d{1,2}:\d{2}(?:[\.,]\d{1,3})?)\]?\s*/g;
  return props.rawTranscriptText.replace(timestampRegex, '').trim();
});

const rawTranscriptParagraphs = computed(() => {
  if (!cleanRawTranscriptForArticle.value) return [];
  // Split the cleaned text by what might be paragraph breaks (double newlines, 
  // or a newline followed by an indent/uppercase - this is a heuristic)
  return cleanRawTranscriptForArticle.value
           .split(/\n\s*\n|\n(?=\s*[A-ZÀ-ÖØ-Þ-—–])/) // Heuristic for paragraphs
           .map(p => p.trim())
           .filter(p => p); 
});

const formatTime = (totalSeconds) => {
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = Math.floor(totalSeconds % 60);
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
};

// Determines if segments should have click-to-seek behavior
const isSegmentClickable = () => {
  return currentTranscriptMode.value === 'interactive_click_sync' || currentTranscriptMode.value === 'interactive_full_sync';
};

// Determines if segments should be highlighted based on video playback
const shouldHighlight = (index) => {
  return (currentTranscriptMode.value === 'interactive_full_sync') && (index === currentlyActiveSegmentIndex.value);
};

// --- Click vs. Drag Logic for segment interaction ---
const onSegmentMouseDown = (event) => {
  if (!isSegmentClickable()) return;
  isDragging.value = false;
  mouseDownPos.value = { x: event.clientX, y: event.clientY };
};
const onSegmentMouseMove = (event) => {
  if (!isSegmentClickable() || !mouseDownPos.value || (mouseDownPos.value.x === 0 && mouseDownPos.value.y === 0 && !event.buttons) ) return;
  const deltaX = Math.abs(event.clientX - mouseDownPos.value.x);
  const deltaY = Math.abs(event.clientY - mouseDownPos.value.y);
  if (deltaX > 3 || deltaY > 3) { 
    isDragging.value = true;
  }
};
const onSegmentMouseUp = (startTime) => {
  if (!isSegmentClickable()) return;
  if (!isDragging.value) { 
    emit('segment-clicked', startTime);
  }
  isDragging.value = false;
  mouseDownPos.value = { x: 0, y: 0 };
};
const handleTimestampClick = (startTime) => {
    if (!isSegmentClickable()) return;
    emit('segment-clicked', startTime);
};

// --- Auto-scroll and Highlighting (only for 'interactive_full_sync') ---
const userHasScrolledManually = ref(false);
let scrollDebounceTimeout = null;
let manualScrollHandlerDebounceTimer = null;

const handleManualScroll = () => {
  if (currentTranscriptMode.value !== 'interactive_full_sync') return; 
  userHasScrolledManually.value = true;
  clearTimeout(scrollDebounceTimeout);
  scrollDebounceTimeout = setTimeout(() => {
    userHasScrolledManually.value = false;
  }, 2500); 
};
const handleManualScrollDebounced = () => {
    clearTimeout(manualScrollHandlerDebounceTimer);
    manualScrollHandlerDebounceTimer = setTimeout(handleManualScroll, 100);
};

const updateActiveSegmentAndScroll = (newTime) => {
  // This function is only relevant for 'interactive_full_sync' mode
  if (currentTranscriptMode.value !== 'interactive_full_sync' || !props.transcriptSegments || props.transcriptSegments.length === 0) {
    currentlyActiveSegmentIndex.value = -1;
    return;
  }
  let activeIdx = -1;
  for (let i = 0; i < props.transcriptSegments.length; i++) {
    const segment = props.transcriptSegments[i];
    const segmentStart = parseFloat(segment.start);
    const segmentDuration = parseFloat(segment.duration);
    let segmentEnd;
    if (i + 1 < props.transcriptSegments.length) {
      segmentEnd = parseFloat(props.transcriptSegments[i + 1].start);
    } else {
      segmentEnd = segmentStart + segmentDuration + 0.5; 
    }
    if (newTime >= segmentStart && newTime < segmentEnd) {
      activeIdx = i;
      break; 
    }
  }
  
  if (currentlyActiveSegmentIndex.value !== activeIdx) {
    currentlyActiveSegmentIndex.value = activeIdx;
  }

  if (activeIdx !== -1 && !userHasScrolledManually.value) { 
    nextTick(() => {
      const activeEl = document.getElementById(`full-transcript-segment-${activeIdx}`);
      if (activeEl && fullTranscriptScrollAreaRef.value) {
        activeEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
      }
    });
  }
};

// Watchers to react to prop changes or mode changes
watch(() => props.currentVideoTime, (newTime) => {
  if (currentTranscriptMode.value === 'interactive_full_sync') {
    updateActiveSegmentAndScroll(newTime);
  }
  // No need to clear highlight here, mode change watcher handles it
});

watch(currentTranscriptMode, (newMode) => {
    if (newMode === 'interactive_full_sync') {
        updateActiveSegmentAndScroll(props.currentVideoTime); 
    } else {
        currentlyActiveSegmentIndex.value = -1; // Clear highlight if not in full sync
    }
    userHasScrolledManually.value = false; 
});

// Initial setup on mount
onMounted(() => {
    if(currentTranscriptMode.value === 'interactive_full_sync') {
        updateActiveSegmentAndScroll(props.currentVideoTime);
    }
});
onUnmounted(() => {
  clearTimeout(scrollDebounceTimeout);
  clearTimeout(manualScrollHandlerDebounceTimer);
});
</script>

<style scoped>
.notebook-page.full-transcript-page {
  width: 100%; flex-grow: 1; display: flex; flex-direction: column;
  overflow: hidden; min-height: 0; padding: 0; box-sizing: border-box;
}
.page-header { 
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 0.75em; border-bottom: 1px solid #eee; padding-bottom: 0.5em; 
  flex-shrink: 0; 
}
.page-title { 
  color: var(--color-heading); font-weight: 600; font-size: 1.5em; 
  margin: 0; border-bottom: none; padding-bottom: 0;
}
.mode-selector-wrapper { display: flex; align-items: center; gap: 8px; }
.mode-label { font-size: 0.9em; color: #555; }
.mode-dropdown {
  padding: 6px 10px; /* Adjusted padding */
  font-size: 0.9em;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: #f8f8f8; /* Light background for dropdown */
  color: #333;
  cursor: pointer;
  min-width: 220px; /* Give it some decent width */
}
.mode-dropdown:hover { border-color: #aaa; }
.mode-dropdown:focus { border-color: #007bff; box-shadow: 0 0 0 1px #007bff; outline: none;}

.transcript-content-wrapper { 
  flex-grow: 1; display: flex; flex-direction: column;
  min-height: 0; overflow: hidden; position: relative; 
}
.transcript-scroll-area { 
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  overflow-y: auto; padding: 15px; background-color: #fff; 
  font-size: 15px; line-height: 1.7; color: #333;
}

/* Styles for Mode 2: Static Article View */
.article-text-formatted { /* For when LLM provides pre-formatted text */
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: 'Georgia', 'Times New Roman', serif; /* More book-like font */
  font-size: 16px;
  line-height: 1.8;
  color: #222;
}
.raw-transcript-as-article h4 {
  font-size: 1.2em; font-weight: 600; margin-top: 1em; margin-bottom: 0.5em;
  color: var(--color-heading);
}
.raw-transcript-as-article h4:first-of-type { margin-top: 0;}
.article-paragraph {
  margin-bottom: 1em;
  /* text-align: justify; */ /* Justify can sometimes create weird spacing */
}

/* Styles for Segmented Display (Modes 1, 3, 4) */
.segmented-transcript-display .transcript-segment-full {
  margin-bottom: 0.4em; /* Slightly tighter spacing */
  padding: 4px 6px; 
  border-radius: 3px;
  display: block; 
  user-select: text; 
  transition: background-color 0.1s ease-out;
}
.segmented-transcript-display .transcript-segment-full.clickable-segment:hover {
  background-color: #e9ecef; /* Lighter hover */
}
.segmented-transcript-display .transcript-segment-full.active-highlight .segment-time { 
  color: #c82333; /* Bootstrap danger red, or your preferred highlight color */
  font-weight: bold; 
}

.segment-time {
  display: inline-block; width: 55px; /* Slightly wider for MM:SS */
  color: #0069d9; /* Bootstrap primary blue, slightly darker */
  font-weight: 500; margin-right: 10px; /* More space after timestamp */
  font-size: 0.85em; /* Slightly smaller timestamp */
  transition: color 0.2s, font-weight 0.2s;
  user-select: none; 
}
.transcript-segment-full.clickable-segment .segment-time { 
    cursor: pointer; 
}

.raw-transcript-text-full { 
  white-space: pre-wrap; word-wrap: break-word; font-family: 'Menlo', 'Consolas', 'Courier New', monospace;
  font-size: 14px; line-height: 1.6; color: #2c3e50; margin: 0;
}
.no-transcript-placeholder-full { 
  display: flex; align-items: center; justify-content: center; 
  height: 100%; text-align: center; color: #888; font-style: italic;
}
</style>